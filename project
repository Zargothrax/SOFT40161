import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

path = '/kaggle/input/home-loan-approval'
testData = pd.read_csv(f"{path}/loan_sanction_test.csv") 
trainData = pd.read_csv(f"{path}/loan_sanction_train.csv") 

trainData.head()
trainData.info()

################################# 1 - LOAN FOR LOOP
print("\n LOAN LOOP")

approvedLoans = 0
deniedLoans = 0
pendingLoans = 0
loanCount = 0

for index, row in trainData.iterrows():
    loanCount += 1
    if row['Loan_Status'] == 'Y':
        approvedLoans += 1
    elif row['Loan_Status'] == 'N':
        deniedLoans += 1
    else:
        pendingLoans += 1

print(f"Number of approved loans: {approvedLoans}")
print(f"Number of denied loans: {deniedLoans}")
print(f"Number of loans pending: {pendingLoans}")
print(f"Total Number of Applications: {loanCount}")

################################# 2 - INCOME SORTING 
print("\n INCOME SORTING")

lowIncome = 4000
mediumIncome = 6500
highIncome = 9000

lowIncomeApplicants = trainData[trainData['ApplicantIncome'] < lowIncome]
mediumIncomeApplicants = trainData[(trainData['ApplicantIncome'] >= lowIncome) & (trainData['ApplicantIncome'] <= mediumIncome)]
highIncomeApplicants = trainData[trainData['ApplicantIncome'] >= highIncome]

lowIncomeCount = len(lowIncomeApplicants)
mediumIncomeCount = len(mediumIncomeApplicants)
highIncomeCount = len(highIncomeApplicants)

maxApplicantIncome = trainData['ApplicantIncome'].max()
averageApplicantIncome = trainData['ApplicantIncome'].mean()
minApplicantIncome = trainData['ApplicantIncome'].min()

print(f"Highest Applicant Income: {maxApplicantIncome}")
print(f"Average Applicant Income: {averageApplicantIncome}")
print(f"Lowest Applicant Income: {minApplicantIncome}")

print(f"Number of Low Income applicants (Less than 4000): {lowIncomeCount}")
print(f"Number of Medium Income applicants (More than 4000, Less than 6500): {mediumIncomeCount}")
print(f"Number of High Income applicants (More than 6500): {highIncomeCount}")

################################### 3-  HOUSEHOLD INCOME CALUCATIONS
print("\n HOUSEHOLD INCOME CALUCATIONS")

trainData['HouseholdIncome'] = trainData['ApplicantIncome'] + trainData['CoapplicantIncome']
print("First 5 rows of incomes")
print(trainData[['ApplicantIncome', 'CoapplicantIncome', 'HouseholdIncome']].head())

maxHouseholdIncome = trainData['HouseholdIncome'].max()
averageHouseholdIncome = trainData['HouseholdIncome'].mean()
minHouseholdIncome = trainData['HouseholdIncome'].min()

print(f"Highest Household Income: {maxHouseholdIncome}")
print(f"Average Household Income: {averageHouseholdIncome}")
print(f"Lowest Household Income: {minHouseholdIncome}")



#################################### 4 - HOUSEHOLD INCOME COUNTS
print("\n HOUSEHOLD INCOME COUNTS")

lowHouseholdIncome = 8000
mediumHouseholdIncome = 18000

lowHouseholdIncomeApplicants = trainData[trainData['HouseholdIncome'] <= lowHouseholdIncome]
mediumHouseholdIncomeApplicants = trainData[(trainData['HouseholdIncome'] > lowHouseholdIncome) & (trainData['HouseholdIncome'] <= mediumHouseholdIncome)]
highHouseholdIncomeApplicants = trainData[trainData['HouseholdIncome'] > mediumHouseholdIncome]

lowHouseholdIncomeCount = len(lowHouseholdIncomeApplicants)
mediumHouseholdIncomeCount = len(mediumHouseholdIncomeApplicants)
highHouseholdIncomeCount = len(highHouseholdIncomeApplicants)

print("Previous Amount Thresholds Doubled")
print(f"Number of Low Household Income applicants: {lowHouseholdIncomeCount}")
print(f"Number of Medium Household Income applicants: {mediumHouseholdIncomeCount}")
print(f"Number of High Household Income applicants: {highHouseholdIncomeCount}")

#################################### DEPDENTS AND MARRIAGE COUNTS AND AVERAGES 
print("\n DEPDENTS AND MARRIAGE")

trainData['Dependents'] = trainData['Dependents'].replace('3+', 3).astype(float)
averageDependents = trainData['Dependents'].mean()

print(f"Average Number of Dependents: {averageDependents:.2f}")

marriedCount = len(trainData[trainData['Married'] == 'Yes'])
unmarriedCount = len(trainData[trainData['Married'] == 'No'])

totalApplicants = len(trainData)

marriedPercentage = (marriedCount / totalApplicants) * 100
unmarriedPercentage = (unmarriedCount / totalApplicants) * 100

print(f"Number of Married Applicants: {marriedCount} ({marriedPercentage:.2f}%)")
print(f"Number of Unmarried Applicants: {unmarriedCount} ({unmarriedPercentage:.2f}%)")

#################################### HOW EDUCATION MAY EFFECT INCOME AND LOAN VALUES
print("\n EDUCATION STATUS RELATIONSHIPS")

graduateGroup = trainData[trainData['Education'] == 'Graduate']
nonGraduateGroup = trainData[trainData['Education'] == 'Not Graduate']

averageLoanGraduate = graduateGroup['LoanAmount'].mean()
averageIncomeGraduate = graduateGroup['ApplicantIncome'].mean()

averageLoanNonGraduate = nonGraduateGroup['LoanAmount'].mean()
averageIncomeNonGraduate = nonGraduateGroup['ApplicantIncome'].mean()

print("Relationship Between Education and Income:")
print(f"Average Loan Amount for Graduates: {averageLoanGraduate:.2f}")
print(f"Average Applicant Income for Graduates: {averageIncomeGraduate:.2f}")
print(f"Average Loan Amount for Non-Graduates: {averageLoanNonGraduate:.2f}")
print(f"Average Applicant Income for Non-Graduates: {averageIncomeNonGraduate:.2f}")

#################################### INITAL CLEANING AND LOAN ANONMOLIES
print("\n CLEANING AND LOAN ANOMOLIES")

trainData['LoanAmount'] = trainData['LoanAmount'] * 1000
trainData['ApplicantIncome'] = trainData['ApplicantIncome'] * 10
trainData['CoapplicantIncome'] = trainData['CoapplicantIncome'] * 10
trainData['HouseholdIncome'] = trainData['ApplicantIncome'] + trainData['CoapplicantIncome']
print(trainData[['ApplicantIncome', 'CoapplicantIncome', 'HouseholdIncome']].head())


averageApplicantIncome = trainData['ApplicantIncome'].mean()
averageHouseholdIncome = trainData['HouseholdIncome'].mean()
averageLoan = trainData['LoanAmount'].mean()

print(f"\nAverage Loan Amount: {averageLoan}")
print(f"Average Household Income: {averageHouseholdIncome}")
print(f"Average Applicant Income: {averageApplicantIncome}")


loanAnomalyMultiplier = 5
anomalousLoanCount = 0  

print("\nApplicants with loan amounts more than 5 times their household income:")

for index, row in trainData.iterrows():
    if row['LoanAmount'] > loanAnomalyMultiplier * row['HouseholdIncome']:
        anomalousLoanCount += 1
        print(f"Applicant ID: {row['Loan_ID']}, Loan Amount: {row['LoanAmount']}, Household Income: {row['HouseholdIncome']}")


print(f"Anomalous Loan Count: {anomalousLoanCount}")

// 

######################### Initial Functions 

def cleanTerm(trainData, column='Loan_Amount_Term'):
    if column not in trainData.columns:
        raise ValueError(f"Column '{column}' not found in the dataframe.")
    trainData[column] = trainData[column] / 12
    return trainData

trainData = cleanTerm(trainData, column='Loan_Amount_Term')

print("5 Random entries of Loan Amount Term (in years):")
random5 = trainData[['Loan_Amount_Term']].sample(n=5)
for value in random5['Loan_Amount_Term']:
    print(f"{value} years")
    
#numerical
def statistics(df, column):
    average = df[column].mean()
    median = df[column].median()
    std_dev = df[column].std()
    
    print(f"\nStatistics for {column}:")
    print(f"Average: {average:.2f}")
    print(f"Median: {median:.2f}")
    print(f"Standard Deviation: {std_dev:.2f}")
    
    return average, median, std_dev


statistics(trainData, 'Dependents')
statistics(trainData, 'ApplicantIncome')
statistics(trainData, 'CoapplicantIncome')
statistics(trainData, 'LoanAmount')


#categorical
def distributionCal(df, column):
    summary = df[column].value_counts().reset_index()
    summary.columns = [column, 'Count']
    summary['Percentage'] = (summary['Count'] / len(df)) * 100
    summary['Percentage'] = summary['Percentage'].apply(lambda x: f"{x:.2f}%")

    print(f"\nSummary for {column} column:")
    print(summary)
    
    return summary

genderSummary = distributionCal(trainData, 'Gender')
MarriedSummary = distributionCal(trainData, 'Married')
EducationSummary = distributionCal(trainData, 'Education')


#Numpy to show relationships example
print("\n Numpy for Income Against Loan")

loanNp = np.array(trainData['LoanAmount'])
incomeNp = np.array(trainData['HouseholdIncome'])

trainData['LoanIncomeRatio'] = loanNp / incomeNp
trainData['LoanMoreThanIncome'] = np.where(loanNp > (2 * incomeNp), 1, 0)
trainData['LoanToIncomePercentage'] = (loanNp / incomeNp) * 100
trainData['LoanToIncomePercentage'] = trainData['LoanToIncomePercentage'].apply(lambda x: f"{x:.2f}%")

print(trainData[['LoanAmount', 'HouseholdIncome','LoanIncomeRatio', 'LoanMoreThanIncome', 'LoanToIncomePercentage']].head())

print("\n Numpy for Income vs Co Applicant Income ratio")

trainData['IncomeRatio'] = np.round(trainData['ApplicantIncome'] / trainData['CoapplicantIncome'], 2)
print(trainData[['ApplicantIncome', 'CoapplicantIncome', 'IncomeRatio']].sample(5))

//

############################# GENDER CLEANING
print("Gender Cleaning")

genderMissing = trainData['Gender'].isnull().sum()
print(f"Missing values for Gender: {genderMissing}")

if genderMissing > 0:
    genderDistrubtion = trainData['Gender'].value_counts(normalize=True)
    print(f"\nGender Distribution:\n{genderDistrubtion}")
    
    malesDistrubtion = int(np.round(genderDistrubtion['Male'] * genderMissing))
    femalesDistrubtion = genderMissing - malesDistrubtion  

    newMalesDistrubtion = ['Male'] * malesDistrubtion
    newFemalesDistrubtion = ['Female'] * femalesDistrubtion
    replacementValues = newMalesDistrubtion + newFemalesDistrubtion
    
    np.random.shuffle(replacementValues)
    trainData.loc[trainData['Gender'].isnull(), 'Gender'] = replacementValues
    genderMissing = trainData['Gender'].isnull().sum()
    print(f"\nMissing values in Gender column were filled with {malesDistrubtion} 'Male' and {femalesDistrubtion} 'Female'")

print(f"New Missing values for Gender: {genderMissing}")

############################# MARRIED CLEANING
print("\n /////////////////")
print("Gender Cleaning")

marriageMissing = trainData['Married'].isnull().sum()
print(f"Missing values for Marriage: {marriageMissing}")

if marriageMissing > 0:
    marriageDistrubtion = trainData['Married'].value_counts(normalize=True)
    print(f"\nDistribution of Marital Status:\n{marriageDistrubtion}")
    
    noDistrubtion = int(np.round(marriageDistrubtion['No'] * marriageMissing))
    yesDistrubtion = marriageMissing - noDistrubtion  

    newNoDistrubtion = ['No'] * noDistrubtion
    newYesDistrubtion = ['Yes'] * yesDistrubtion
    replacementMarriageValues = newNoDistrubtion + newYesDistrubtion
    
    np.random.shuffle(replacementMarriageValues)
    trainData.loc[trainData['Married'].isnull(), 'Married'] = replacementMarriageValues
    marriageMissing = trainData['Married'].isnull().sum()
    print(f"\nMissing values in Marriage column were filled with {noDistrubtion} 'No' and {yesDistrubtion} 'Yes'")

print(f"New Missing values for Marriage: {marriageMissing}")

############################# DEPENDANTS CLEANING
print("\n /////////////////")
print("Dependants Cleaning")


dependentsCount = trainData['Dependents'].value_counts()
print("\nCount of each option in the 'Dependents' column:")
print(dependentsCount)


missingDependents = trainData['Dependents'].isnull().sum()
if missingDependents < 1:
    print(f"\nThere are no missing values in the 'Dependents' column.")
else:
    print(f"\nMissing values in 'Dependents' column: {missingDependents}")


withKids = trainData[trainData['Dependents'] > 0]
withoutKids = trainData[trainData['Dependents'] == 0]


withKidsCount = withKids.shape[0]
withoutKidsCount = withoutKids.shape[0]
totalApplicants = trainData.shape[0]

withKidsPercentage = (withKidsCount / totalApplicants) * 100
withoutKidsPercentage = (withoutKidsCount / totalApplicants) * 100


averageKids = round(withKids['Dependents'].mean())

print(f"\nTotal Applicants: {totalApplicants}")
print(f"Applicants with Kids: {withKidsCount} ({withKidsPercentage:.2f}%)")
print(f"Applicants without Kids: {withoutKidsCount} ({withoutKidsPercentage:.2f}%)")
print(f"\nRounded average number of kids for applicants with kids: {averageKids}")



def dependantCleaningdistribution(dataframe, missing_count, withoutKidsPercentage, withKidsPercentage, averageKids):

    fillWithoutKids = int(round(missing_count * (withoutKidsPercentage / 100)))
    fillWithKids = missing_count - fillWithoutKids
    
    print(f"\nMissing values distribution:")
    print(f"Fill {fillWithoutKids} values with 0 (no kids).")
    print(f"Fill {fillWithKids} values with {averageKids} (average kids).")
    

    def fillDependents(row):
        nonlocal fillWithoutKids, fillWithKids  
        if pd.isnull(row['Dependents']):
            if fillWithoutKids > 0:
                fillWithoutKids -= 1
                return 0
            elif fillWithKids > 0:
                fillWithKids -= 1
                return averageKids
        return row['Dependents']
    

    dataframe['Dependents'] = dataframe.apply(fillDependents, axis=1)
    return dataframe


trainData = dependantCleaningdistribution(trainData, missingDependents, withoutKidsPercentage, withKidsPercentage, averageKids)

newMissingDependents = trainData['Dependents'].isnull().sum()
print(f"\nNew Missing values in 'Dependents': {newMissingDependents}")

updatedDependentsCount = trainData['Dependents'].value_counts()
print(f"\nUpdated Distribution of Dependents:")
print(updatedDependentsCount)


############################# EDUCATION CLEANING (non applicable)
print("\n /////////////////")
print("\nEducation Cleaning")

missingEducation = trainData['Education'].isnull().sum()
if missingEducation < 1:
    print(f"\nThere are no missing values in the 'Education' column.")
else:
    print(f"\nMissing values in 'Education' column: {missingEducation}")

income_summary_education = trainData.groupby('Education')['ApplicantIncome'].describe()

print("\nIncome Summary Statistics by Education Level")
print(income_summary_education)


############################# SELF EMPLOYED CLEANING (1)
print("\n /////////////////")
print("Self Employed Cleaning")

missingEmployed = trainData['Self_Employed'].isnull().sum()
if missingEmployed < 1:
    print(f"\nThere are no missing values in the 'Self_Employed' column.")
else:
    print(f"\nMissing values in 'Self_Employed' column: {missingEmployed}")

print(f"Income data will be used to clean this section, {missingEmployed} values will be updated based on clean Income data for better accuracy ")

############################# INCOME CLEANING 
print("\n /////////////////")
print("Income Cleaning")

missingIncome = trainData['ApplicantIncome'].isnull().sum()
if missingIncome < 1:
    print(f"\nThere are no missing values in the 'ApplicantIncome' column.")
else:
    print(f"\nMissing values in 'ApplicantIncome' column: {missingIncome}")

Q1 = trainData['ApplicantIncome'].quantile(0.25)
Q3 = trainData['ApplicantIncome'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outliers = trainData[(trainData['ApplicantIncome'] < lower_bound) | (trainData['ApplicantIncome'] > upper_bound)]
medianIncome = trainData['ApplicantIncome'].median()
trainData['ApplicantIncome'] = trainData['ApplicantIncome'].apply(lambda x: medianIncome if (x < lower_bound) or (x > upper_bound) else x)

print(f"\nNumber of outliers detected using IQR: {outliers.shape[0]}")
print("\nIncome Distribution after Outlier Replacement:")
print(trainData['ApplicantIncome'].describe())

############################# SELF EMPLOYED CLEANING (2)
print("\n /////////////////")
print("Self Employed Cleaning")


selfEmployedCount = trainData['Self_Employed'].value_counts()
print(f"\nDistribution of 'Self_Employed' column:")
print(selfEmployedCount)

print(f"\nCompare Education by Self_Employed columns:")
compare = trainData.groupby(['Education', 'Self_Employed']).size().unstack(fill_value=0)
print(compare)

print("\nIncome Distribution by Education and Self-Employed:")
incomeSummary = trainData.groupby(['Education', 'Self_Employed'])['ApplicantIncome'].describe()
print(incomeSummary)

def employmentCleaning(row, incomeSummary):
    education = row['Education']
    income = row['ApplicantIncome']  
    statsNo = incomeSummary.loc[(education, 'No')]  # stats for 'Not Self Employed'
    statsYes = incomeSummary.loc[(education, 'Yes')]  # stats for 'Self Employed'

    if income < statsNo['mean'] and income < statsYes['mean']:
        return 'No'
    elif income >= statsYes['mean']:
        return 'Yes' 
    else:
        return 'No'


trainData['Self_Employed'] = trainData.apply(
    lambda row: employmentCleaning(row, incomeSummary) 
    if pd.isnull(row['Self_Employed']) else row['Self_Employed'], axis=1
)

selfEmployedCountUpdated = trainData['Self_Employed'].value_counts()
print(f"\nUpdated Distribution of 'Self_Employed' column after filling missing values:")
print(selfEmployedCountUpdated)

############################# COAPPLICANT INCOME CLEANING
print("\n /////////////////")
print("CoApplicant Income Cleaning")

missingCoIncome = trainData['CoapplicantIncome'].isnull().sum()
if missingCoIncome < 1:
    print(f"\nThere are no missing values in the 'CoapplicantIncome' column.")
else:
    print(f"\nMissing values in 'CoapplicantIncome' column: {missingCoIncome}")




 





