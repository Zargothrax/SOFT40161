import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

path = '/kaggle/input/home-loan-approval'
testData = pd.read_csv(f"{path}/loan_sanction_test.csv") 
trainData = pd.read_csv(f"{path}/loan_sanction_train.csv") 

trainData.head()
trainData.info()

################################# 1 - LOAN FOR LOOP
print("\n LOAN LOOP")

approvedLoans = 0
deniedLoans = 0
pendingLoans = 0
loanCount = 0

for index, row in trainData.iterrows():
    loanCount += 1
    if row['Loan_Status'] == 'Y':
        approvedLoans += 1
    elif row['Loan_Status'] == 'N':
        deniedLoans += 1
    else:
        pendingLoans += 1

print(f"Number of approved loans: {approvedLoans}")
print(f"Number of denied loans: {deniedLoans}")
print(f"Number of loans pending: {pendingLoans}")
print(f"Total Number of Applications: {loanCount}")

################################# 2 - INCOME SORTING 
print("\n INCOME SORTING")

lowIncome = 4000
mediumIncome = 6500
highIncome = 9000

lowIncomeApplicants = trainData[trainData['ApplicantIncome'] < lowIncome]
mediumIncomeApplicants = trainData[(trainData['ApplicantIncome'] >= lowIncome) & (trainData['ApplicantIncome'] <= mediumIncome)]
highIncomeApplicants = trainData[trainData['ApplicantIncome'] >= highIncome]

lowIncomeCount = len(lowIncomeApplicants)
mediumIncomeCount = len(mediumIncomeApplicants)
highIncomeCount = len(highIncomeApplicants)

maxApplicantIncome = trainData['ApplicantIncome'].max()
averageApplicantIncome = trainData['ApplicantIncome'].mean()
minApplicantIncome = trainData['ApplicantIncome'].min()

print(f"Highest Applicant Income: {maxApplicantIncome}")
print(f"Average Applicant Income: {averageApplicantIncome}")
print(f"Lowest Applicant Income: {minApplicantIncome}")

print(f"Number of Low Income applicants (Less than 4000): {lowIncomeCount}")
print(f"Number of Medium Income applicants (More than 4000, Less than 6500): {mediumIncomeCount}")
print(f"Number of High Income applicants (More than 6500): {highIncomeCount}")

################################### 3-  HOUSEHOLD INCOME CALUCATIONS
print("\n HOUSEHOLD INCOME CALUCATIONS")

trainData['HouseholdIncome'] = trainData['ApplicantIncome'] + trainData['CoapplicantIncome']
print("First 5 rows of incomes")
print(trainData[['ApplicantIncome', 'CoapplicantIncome', 'HouseholdIncome']].head())

maxHouseholdIncome = trainData['HouseholdIncome'].max()
averageHouseholdIncome = trainData['HouseholdIncome'].mean()
minHouseholdIncome = trainData['HouseholdIncome'].min()

print(f"Highest Household Income: {maxHouseholdIncome}")
print(f"Average Household Income: {averageHouseholdIncome}")
print(f"Lowest Household Income: {minHouseholdIncome}")



#################################### 4 - HOUSEHOLD INCOME COUNTS
print("\n HOUSEHOLD INCOME COUNTS")

lowHouseholdIncome = 8000
mediumHouseholdIncome = 18000

lowHouseholdIncomeApplicants = trainData[trainData['HouseholdIncome'] <= lowHouseholdIncome]
mediumHouseholdIncomeApplicants = trainData[(trainData['HouseholdIncome'] > lowHouseholdIncome) & (trainData['HouseholdIncome'] <= mediumHouseholdIncome)]
highHouseholdIncomeApplicants = trainData[trainData['HouseholdIncome'] > mediumHouseholdIncome]

lowHouseholdIncomeCount = len(lowHouseholdIncomeApplicants)
mediumHouseholdIncomeCount = len(mediumHouseholdIncomeApplicants)
highHouseholdIncomeCount = len(highHouseholdIncomeApplicants)

print("Previous Amount Thresholds Doubled")
print(f"Number of Low Household Income applicants: {lowHouseholdIncomeCount}")
print(f"Number of Medium Household Income applicants: {mediumHouseholdIncomeCount}")
print(f"Number of High Household Income applicants: {highHouseholdIncomeCount}")

#################################### DEPDENTS AND MARRIAGE COUNTS AND AVERAGES 
print("\n DEPDENTS AND MARRIAGE")

trainData['Dependents'] = trainData['Dependents'].replace('3+', 3).astype(float)
averageDependents = trainData['Dependents'].mean()

print(f"Average Number of Dependents: {averageDependents:.2f}")

marriedCount = len(trainData[trainData['Married'] == 'Yes'])
unmarriedCount = len(trainData[trainData['Married'] == 'No'])

totalApplicants = len(trainData)

marriedPercentage = (marriedCount / totalApplicants) * 100
unmarriedPercentage = (unmarriedCount / totalApplicants) * 100

print(f"Number of Married Applicants: {marriedCount} ({marriedPercentage:.2f}%)")
print(f"Number of Unmarried Applicants: {unmarriedCount} ({unmarriedPercentage:.2f}%)")

#################################### HOW EDUCATION MAY EFFECT INCOME AND LOAN VALUES
print("\n EDUCATION STATUS RELATIONSHIPS")

graduateGroup = trainData[trainData['Education'] == 'Graduate']
nonGraduateGroup = trainData[trainData['Education'] == 'Not Graduate']

averageLoanGraduate = graduateGroup['LoanAmount'].mean()
averageIncomeGraduate = graduateGroup['ApplicantIncome'].mean()

averageLoanNonGraduate = nonGraduateGroup['LoanAmount'].mean()
averageIncomeNonGraduate = nonGraduateGroup['ApplicantIncome'].mean()

print("Relationship Between Education and Income:")
print(f"Average Loan Amount for Graduates: {averageLoanGraduate:.2f}")
print(f"Average Applicant Income for Graduates: {averageIncomeGraduate:.2f}")
print(f"Average Loan Amount for Non-Graduates: {averageLoanNonGraduate:.2f}")
print(f"Average Applicant Income for Non-Graduates: {averageIncomeNonGraduate:.2f}")

#################################### INITAL CLEANING AND LOAN ANONMOLIES
print("\n CLEANING AND LOAN ANOMOLIES")

trainData['LoanAmount'] = trainData['LoanAmount'] * 1000
trainData['ApplicantIncome'] = trainData['ApplicantIncome'] * 10
trainData['CoapplicantIncome'] = trainData['CoapplicantIncome'] * 10
trainData['HouseholdIncome'] = trainData['ApplicantIncome'] + trainData['CoapplicantIncome']
print(trainData[['ApplicantIncome', 'CoapplicantIncome', 'HouseholdIncome']].head())


averageApplicantIncome = trainData['ApplicantIncome'].mean()
averageHouseholdIncome = trainData['HouseholdIncome'].mean()
averageLoan = trainData['LoanAmount'].mean()

print(f"\nAverage Loan Amount: {averageLoan}")
print(f"Average Household Income: {averageHouseholdIncome}")
print(f"Average Applicant Income: {averageApplicantIncome}")


loanAnomalyMultiplier = 5
anomalousLoanCount = 0  

print("\nApplicants with loan amounts more than 5 times their household income:")

for index, row in trainData.iterrows():
    if row['LoanAmount'] > loanAnomalyMultiplier * row['HouseholdIncome']:
        anomalousLoanCount += 1
        print(f"Applicant ID: {row['Loan_ID']}, Loan Amount: {row['LoanAmount']}, Household Income: {row['HouseholdIncome']}")


print(f"Anomalous Loan Count: {anomalousLoanCount}")

// 

######################### Initial Functions 

def cleanTerm(trainData, column='Loan_Amount_Term'):
    if column not in trainData.columns:
        raise ValueError(f"Column '{column}' not found in the dataframe.")
    trainData[column] = trainData[column] / 12
    return trainData

trainData = cleanTerm(trainData, column='Loan_Amount_Term')

print("5 Random entries of Loan Amount Term (in years):")
random5 = trainData[['Loan_Amount_Term']].sample(n=5)
for value in random5['Loan_Amount_Term']:
    print(f"{value} years")
    
#numerical
def statistics(df, column):
    average = df[column].mean()
    median = df[column].median()
    std_dev = df[column].std()
    
    print(f"\nStatistics for {column}:")
    print(f"Average: {average:.2f}")
    print(f"Median: {median:.2f}")
    print(f"Standard Deviation: {std_dev:.2f}")
    
    return average, median, std_dev


statistics(trainData, 'Dependents')
statistics(trainData, 'ApplicantIncome')
statistics(trainData, 'CoapplicantIncome')
statistics(trainData, 'LoanAmount')


#categorical
def distributionCal(df, column):
    summary = df[column].value_counts().reset_index()
    summary.columns = [column, 'Count']
    summary['Percentage'] = (summary['Count'] / len(df)) * 100
    summary['Percentage'] = summary['Percentage'].apply(lambda x: f"{x:.2f}%")

    print(f"\nSummary for {column} column:")
    print(summary)
    
    return summary

genderSummary = distributionCal(trainData, 'Gender')
MarriedSummary = distributionCal(trainData, 'Married')
EducationSummary = distributionCal(trainData, 'Education')


#Numpy to show relationships example
print("\n Numpy for Income Against Loan")

loanNp = np.array(trainData['LoanAmount'])
incomeNp = np.array(trainData['HouseholdIncome'])

trainData['LoanIncomeRatio'] = loanNp / incomeNp
trainData['LoanMoreThanIncome'] = np.where(loanNp > (2 * incomeNp), 1, 0)
trainData['LoanToIncomePercentage'] = (loanNp / incomeNp) * 100
trainData['LoanToIncomePercentage'] = trainData['LoanToIncomePercentage'].apply(lambda x: f"{x:.2f}%")

print(trainData[['LoanAmount', 'HouseholdIncome','LoanIncomeRatio', 'LoanMoreThanIncome', 'LoanToIncomePercentage']].head())

print("\n Numpy for Income vs Co Applicant Income ratio")

trainData['IncomeRatio'] = np.round(trainData['ApplicantIncome'] / trainData['CoapplicantIncome'], 2)
print(trainData[['ApplicantIncome', 'CoapplicantIncome', 'IncomeRatio']].sample(5))

//

############################# GENDER CLEANING
print("Gender Cleaning")

genderMissing = trainData['Gender'].isnull().sum()
print(f"Missing values for Gender: {genderMissing}")

if genderMissing > 0:
    genderDistrubtion = trainData['Gender'].value_counts(normalize=True)
    print(f"\nGender Distribution:\n{genderDistrubtion}")
    
    malesDistrubtion = int(np.round(genderDistrubtion['Male'] * genderMissing))
    femalesDistrubtion = genderMissing - malesDistrubtion  

    newMalesDistrubtion = ['Male'] * malesDistrubtion
    newFemalesDistrubtion = ['Female'] * femalesDistrubtion
    replacementValues = newMalesDistrubtion + newFemalesDistrubtion
    
    np.random.shuffle(replacementValues)
    trainData.loc[trainData['Gender'].isnull(), 'Gender'] = replacementValues
    genderMissing = trainData['Gender'].isnull().sum()
    print(f"\nMissing values in Gender column were filled with {malesDistrubtion} 'Male' and {femalesDistrubtion} 'Female'")

print(f"New Missing values for Gender: {genderMissing}")

############################# MARRIED CLEANING
print("\n /////////////////")
print("Gender Cleaning")

marriageMissing = trainData['Married'].isnull().sum()
print(f"Missing values for Marriage: {marriageMissing}")

if marriageMissing > 0:
    marriageDistrubtion = trainData['Married'].value_counts(normalize=True)
    print(f"\nDistribution of Marital Status:\n{marriageDistrubtion}")
    
    noDistrubtion = int(np.round(marriageDistrubtion['No'] * marriageMissing))
    yesDistrubtion = marriageMissing - noDistrubtion  

    newNoDistrubtion = ['No'] * noDistrubtion
    newYesDistrubtion = ['Yes'] * yesDistrubtion
    replacementMarriageValues = newNoDistrubtion + newYesDistrubtion
    
    np.random.shuffle(replacementMarriageValues)
    trainData.loc[trainData['Married'].isnull(), 'Married'] = replacementMarriageValues
    marriageMissing = trainData['Married'].isnull().sum()
    print(f"\nMissing values in Marriage column were filled with {noDistrubtion} 'No' and {yesDistrubtion} 'Yes'")

print(f"New Missing values for Marriage: {marriageMissing}")

############################# DEPENDANTS CLEANING
print("\n /////////////////")
print("Dependants Cleaning")


dependentsCount = trainData['Dependents'].value_counts()
print("\nCount of each option in the 'Dependents' column:")
print(dependentsCount)


missingDependents = trainData['Dependents'].isnull().sum()
if missingDependents < 1:
    print(f"\nThere are no missing values in the 'Dependents' column.")
else:
    print(f"\nMissing values in 'Dependents' column: {missingDependents}")


withKids = trainData[trainData['Dependents'] > 0]
withoutKids = trainData[trainData['Dependents'] == 0]


withKidsCount = withKids.shape[0]
withoutKidsCount = withoutKids.shape[0]
totalApplicants = trainData.shape[0]

withKidsPercentage = (withKidsCount / totalApplicants) * 100
withoutKidsPercentage = (withoutKidsCount / totalApplicants) * 100


averageKids = round(withKids['Dependents'].mean())

print(f"\nTotal Applicants: {totalApplicants}")
print(f"Applicants with Kids: {withKidsCount} ({withKidsPercentage:.2f}%)")
print(f"Applicants without Kids: {withoutKidsCount} ({withoutKidsPercentage:.2f}%)")
print(f"\nRounded average number of kids for applicants with kids: {averageKids}")



def dependantCleaningdistribution(dataframe, missing_count, withoutKidsPercentage, withKidsPercentage, averageKids):

    fillWithoutKids = int(round(missing_count * (withoutKidsPercentage / 100)))
    fillWithKids = missing_count - fillWithoutKids
    
    print(f"\nMissing values distribution:")
    print(f"Fill {fillWithoutKids} values with 0 (no kids).")
    print(f"Fill {fillWithKids} values with {averageKids} (average kids).")
    

    def fillDependents(row):
        nonlocal fillWithoutKids, fillWithKids  
        if pd.isnull(row['Dependents']):
            if fillWithoutKids > 0:
                fillWithoutKids -= 1
                return 0
            elif fillWithKids > 0:
                fillWithKids -= 1
                return averageKids
        return row['Dependents']
    

    dataframe['Dependents'] = dataframe.apply(fillDependents, axis=1)
    return dataframe


trainData = dependantCleaningdistribution(trainData, missingDependents, withoutKidsPercentage, withKidsPercentage, averageKids)

newMissingDependents = trainData['Dependents'].isnull().sum()
print(f"\nNew Missing values in 'Dependents': {newMissingDependents}")

updatedDependentsCount = trainData['Dependents'].value_counts()
print(f"\nUpdated Distribution of Dependents:")
print(updatedDependentsCount)


############################# EDUCATION CLEANING (non applicable)
print("\n /////////////////")
print("\nEducation Cleaning")

missingEducation = trainData['Education'].isnull().sum()
if missingEducation < 1:
    print(f"\nThere are no missing values in the 'Education' column.")
else:
    print(f"\nMissing values in 'Education' column: {missingEducation}")

income_summary_education = trainData.groupby('Education')['ApplicantIncome'].describe()

print("\nIncome Summary Statistics by Education Level")
print(income_summary_education)


############################# SELF EMPLOYED CLEANING (1)
print("\n /////////////////")
print("Self Employed Cleaning")

missingEmployed = trainData['Self_Employed'].isnull().sum()
if missingEmployed < 1:
    print(f"\nThere are no missing values in the 'Self_Employed' column.")
else:
    print(f"\nMissing values in 'Self_Employed' column: {missingEmployed}")

print(f"Income data will be used to clean this section, {missingEmployed} values will be updated based on clean Income data for better accuracy ")

############################# INCOME CLEANING 
print("\n /////////////////")
print("Income Cleaning")

missingIncome = trainData['ApplicantIncome'].isnull().sum()
if missingIncome < 1:
    print(f"\nThere are no missing values in the 'ApplicantIncome' column.")
else:
    print(f"\nMissing values in 'ApplicantIncome' column: {missingIncome}")

Q1 = trainData['ApplicantIncome'].quantile(0.25)
Q3 = trainData['ApplicantIncome'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outliers = trainData[(trainData['ApplicantIncome'] < lower_bound) | (trainData['ApplicantIncome'] > upper_bound)]
medianIncome = trainData['ApplicantIncome'].median()
trainData['ApplicantIncome'] = trainData['ApplicantIncome'].apply(lambda x: medianIncome if (x < lower_bound) or (x > upper_bound) else x)

print(f"\nNumber of outliers detected using IQR: {outliers.shape[0]}")
print("\nIncome Distribution after Outlier Replacement:")
print(trainData['ApplicantIncome'].describe())

############################# SELF EMPLOYED CLEANING (2)
print("\n /////////////////")
print("Self Employed Cleaning")


selfEmployedCount = trainData['Self_Employed'].value_counts()
print(f"\nDistribution of 'Self_Employed' column:")
print(selfEmployedCount)

print(f"\nCompare Education by Self_Employed columns:")
compare = trainData.groupby(['Education', 'Self_Employed']).size().unstack(fill_value=0)
print(compare)

print("\nIncome Distribution by Education and Self-Employed:")
incomeSummary = trainData.groupby(['Education', 'Self_Employed'])['ApplicantIncome'].describe()
print(incomeSummary)

def employmentCleaning(row, incomeSummary):
    education = row['Education']
    income = row['ApplicantIncome']  
    statsNo = incomeSummary.loc[(education, 'No')]  # stats for 'Not Self Employed'
    statsYes = incomeSummary.loc[(education, 'Yes')]  # stats for 'Self Employed'

    if income < statsNo['mean'] and income < statsYes['mean']:
        return 'No'
    elif income >= statsYes['mean']:
        return 'Yes' 
    else:
        return 'No'


trainData['Self_Employed'] = trainData.apply(
    lambda row: employmentCleaning(row, incomeSummary) 
    if pd.isnull(row['Self_Employed']) else row['Self_Employed'], axis=1
)

selfEmployedCountUpdated = trainData['Self_Employed'].value_counts()
print(f"\nUpdated Distribution of 'Self_Employed' column after filling missing values:")
print(selfEmployedCountUpdated)

############################# COAPPLICANT INCOME CLEANING
print("\n /////////////////")
print("CoApplicant Income Cleaning")

missingCoIncome = trainData['CoapplicantIncome'].isnull().sum()
if missingCoIncome < 1:
    print(f"\nThere are no missing values in the 'CoapplicantIncome' column.")
else:
    print(f"\nMissing values in 'CoapplicantIncome' column: {missingCoIncome}")

############################# LOAN AMOUNT CLEANING
print("\n /////////////////")
print("Loan Amount Cleaning")

missingLoan = trainData['LoanAmount'].isnull().sum()
if missingLoan < 1:
    print(f"\nThere are no missing values in the 'Loan Amount' column.")
else:
    print(f"\nMissing values in 'Loan Amount' column: {missingLoan}")

trainData['HouseholdIncome'] = trainData['ApplicantIncome'] + trainData['CoapplicantIncome']
LoanIncomeRatio = (trainData['LoanAmount'] / trainData['HouseholdIncome']).mean()
print(LoanIncomeRatio)

Q1loan = trainData['LoanAmount'].quantile(0.25)
Q3loan = trainData['LoanAmount'].quantile(0.75)
IQRloan = Q3loan - Q1loan

lowerBoundLoan = Q1loan - 1.5 * IQRloan
upperBoundLoan = Q3loan + 1.5 * IQRloan

Q1income = trainData['HouseholdIncome'].quantile(0.25)
Q3income = trainData['HouseholdIncome'].quantile(0.75)
IQRincome = Q3income - Q1income

lowerBoundIncome = Q1income - 1.5 * IQRincome
upperBoundIncome = Q3income + 1.5 * IQRincome

def LoanCleaning(row, LoanIncomeRatio, lowerBoundLoan, upperBoundLoan, lowerBoundIncome, upperBoundIncome):
    if row['LoanAmount'] < lowerBoundLoan or row['LoanAmount'] > upperBoundLoan:
        row['LoanAmount'] = trainData['LoanAmount'].median()
    return row

trainData = trainData.apply(lambda row: LoanCleaning(row, LoanIncomeRatio, lowerBoundLoan, upperBoundLoan, lowerBoundIncome, upperBoundIncome), axis=1)

def LoanReplaceNull(row, LoanIncomeRatio):
    if pd.isnull(row['LoanAmount']):
        return row['HouseholdIncome'] * LoanIncomeRatio
    return row['LoanAmount']

trainData['LoanAmount'] = trainData.apply(lambda row: LoanReplaceNull(row, LoanIncomeRatio), axis=1)

print(f"\nUpdated distribution of 'LoanAmount' after filling missing values and cleaning outliers:")
print(trainData['LoanAmount'].describe())

############################# LOAN TERM CLEANING
print("\n /////////////////")
print("Loan Amount Term Cleaning")

LoanTerms = trainData['Loan_Amount_Term'].unique()
print(f"\nUnique values in 'Loan Amount Term' column: {LoanTerms}")

missingLoanAmountTerm = trainData['Loan_Amount_Term'].isnull().sum()
if missingLoanAmountTerm > 0:
    print(f"\nMissing values in 'Loan Amount Term' column: {missingLoanAmountTerm}")
else:
    print(f"\nNo missing values in 'Loan Amount Term' column")

mostCommonTerm = trainData['Loan_Amount_Term'].mode()[0]

loanAmountTermCount = trainData['Loan_Amount_Term'].value_counts()
print(f"\nUpdated distribution of 'Loan Amount Term' column:")
print(loanAmountTermCount)

shortLoanTerms = trainData[trainData['Loan_Amount_Term'] < 7]

print(f"\nRows where 'Loan_Amount_Term' is under 10 years (less than 120 months):")
print(shortLoanTerms)
print(f"Most common Loan_Amount_Term: {mostCommonTerm}")

trainData['Loan_Amount_Term'] = trainData['Loan_Amount_Term'].fillna(mostCommonTerm)
print("\nMissing values filled with the most common loan term.")

lowerBound = 12  
upperBound = 420

outliers = trainData[(trainData['Loan_Amount_Term'] < lowerBound) | (trainData['Loan_Amount_Term'] > upperBound)]
print(f"\nOutliers detected:\n{outliers[['Loan_Amount_Term']]}")

trainData.loc[(trainData['Loan_Amount_Term'] < lowerBound) | 
              (trainData['Loan_Amount_Term'] > upperBound), 'Loan_Amount_Term'] = mostCommonTerm

print("\nOutliers replaced with the most common loan term.")

print("\nUpdated Loan_Amount_Term distribution:")
print(trainData['Loan_Amount_Term'].value_counts())

############################# CREDIT HISTORY CLEANING
print("\n/////////////////")
print("Credit History Cleaning")

missingCreditHistory = trainData['Credit_History'].isnull().sum()
print(f"\nMissing values in 'Credit_History': {missingCreditHistory}")

incomeQuantiles = trainData['HouseholdIncome'].quantile([0.25, 0.5, 0.75])
print(f"\nHousehold Income Quantiles:\n{incomeQuantiles}")

trainData['IncomeGroup'] = pd.cut(
    trainData['HouseholdIncome'],
    bins=[0, incomeQuantiles[0.25], incomeQuantiles[0.5], incomeQuantiles[0.75], trainData['HouseholdIncome'].max()],
    labels=['Low', 'Medium', 'High', 'Very High'],
    include_lowest=True
)

creditHistoryInfo = trainData.groupby(['Education', 'IncomeGroup'])['Credit_History'].value_counts(normalize=True).unstack(fill_value=0)
print(f"\nLikelihood of Credit History by Education and Income Group:\n{creditHistoryInfo}")

def CredithistoryChance(row):
    if pd.isnull(row['Credit_History']):
        education = row['Education']
        incomeGroup = row['IncomeGroup']
        if (education, incomeGroup) in creditHistoryInfo.index:
            likelihoods = creditHistoryInfo.loc[(education, incomeGroup)]
            return 1.0 if likelihoods[1.0] > likelihoods[0.0] else 0.0
    else:
        return row['Credit_History']


trainData['Credit_History'] = trainData.apply(CredithistoryChance, axis=1)
trainData.drop(columns=['IncomeGroup'], inplace=True)
updatedCreditHistoryCount = trainData['Credit_History'].value_counts()
print(f"\nUpdated Distribution of 'Credit_History':\n{updatedCreditHistoryCount}")

missingCreditHistory = trainData['Credit_History'].isnull().sum()
print(f"\nMissing values in 'Credit_History': {missingCreditHistory}")


############################# PROPERTY AREA CLEANING
print("\n/////////////////")
print("Property Area Cleaning")

missingPropertyArea = trainData['Property_Area'].isnull().sum()
print(f"\nMissing values in 'Property Area': {missingPropertyArea}")

AreaValues = trainData['Property_Area'].unique()
print(f"\nUnique values in 'Property Area' column: {AreaValues}")

areaLoanStats = trainData.groupby('Property_Area')['LoanAmount'].describe()
print("\nLoan Amount Values:")
print(areaLoanStats)

############################# GRAPH 1 - MARRIAGE DISTRIBUTION BOX CHART
print("\n/////////////////")
print("Graph 1: Marriage Box Plot")

plt.figure(figsize=(8, 6))

sns.countplot(data=trainData, x='Married')

plt.title('Distribution of Marriage Status')
plt.xlabel('Married Status')
plt.ylabel('Count')
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

############################# GRAPH 2 - LOAN AMOUNT BY LOAN TERM GROUPS
print("\n/////////////////")
print("Loan Amount by Loan Term Scatterplot")

plt.figure(figsize=(10, 6))
sns.scatterplot(data=trainData, x='Loan_Amount_Term', y='LoanAmount', hue='Loan_Status')

plt.title('Relationship between Loan Amount and Loan Term')
plt.xlabel('Loan Amount (Years)')
plt.ylabel('Loan Amount')
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

############################# GRAPH 3 - HOW DOES EDUCATION AND EMPLOYMENT EFFECT INCOME POINT CHART
print("\n/////////////////")
print("Education/Employment effect on Income Point Chart")

plt.figure(figsize=(12, 8))

sns.pointplot(
    data=trainData, 
    x='Education', 
    y='HouseholdIncome', 
    hue='Self_Employed', 
    markers='o', 
    linestyles='-', 
    dodge=True 
)

plt.title('Comparison of Household Income by Education and Self-Employment')
plt.xlabel('Education Level')
plt.ylabel('Household Income')
plt.xticks(rotation=20)
plt.legend(title='Self-Employment')
plt.tight_layout()
plt.show()


############################# GRAPH 4 - PROPERTY AREA DISTRIBTUION AGAINST INCOME BRACKETS
print("\n/////////////////")
print("Property Area Disribution on Income Brackets")

filteredData = trainData[trainData['HouseholdIncome'] <= 200000].copy()
incomeQuantiles = trainData['HouseholdIncome'].quantile([0.25, 0.5, 0.75])

trainData['IncomeGroup'] = pd.cut(
    trainData['HouseholdIncome'],
    bins=[0, incomeQuantiles[0.25], incomeQuantiles[0.5], incomeQuantiles[0.75], trainData['HouseholdIncome'].max()],
    labels=['Low', 'Medium', 'High', 'Very High'],
    include_lowest=True
)

filteredData = trainData.groupby(['Property_Area', 'IncomeGroup']).size().reset_index(name='Count')

plt.figure(figsize=(10, 6))
sns.barplot(
    x="Property_Area", 
    y="Count", 
    hue="IncomeGroup", 
    data=filteredData, 
    palette="Set2"
)

plt.title("Income Bracket Distribution by Property Area", fontsize=16)
plt.xlabel("Property Area")
plt.ylabel("Count of Individuals")
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.legend(title="Income Group")

plt.tight_layout()
plt.show()

############################# GRAPH 5 - HOUSEHOLD INCOME AGAINST INCOME BY INCOME CLUSTERS (INTERACTABLE)
print("\n/////////////////")
print("Household Income Against Loan (Interactable)")

#cleaning data bought over due to error
filteredData = trainData[trainData['HouseholdIncome'] <= 200000].copy()
incomeQuantiles = filteredData['HouseholdIncome'].quantile([0.25, 0.5, 0.75])
filteredData['IncomeGroup'] = pd.cut(
    filteredData['HouseholdIncome'],
    bins=[0, incomeQuantiles[0.25], incomeQuantiles[0.5], incomeQuantiles[0.75], filteredData['HouseholdIncome'].max()],
    labels=['Low', 'Medium', 'High', 'Very High'],
    include_lowest=True
)

fig = px.scatter(
    filteredData,
    x="HouseholdIncome",
    y="LoanAmount",
    color="IncomeGroup",
    symbol="Loan_Status", 
    hover_data=["Loan_ID", "Loan_Status", "Gender", "Education", "Self_Employed","Married"], 
    title="Graph 5: Interactive Scatter Plot of Household Income vs Loan Amount with Approval Status and Income Bracket",
    labels={
        "HouseholdIncome": "Household Income",
        "LoanAmount": "Loan Amount",
        "IncomeGroup": "Income Group",
        "Loan_Status": "Loan Approval Status"
    },
    symbol_map={"Y": "circle", "N": "x"},  
)

fig.show()


############################# GRAPH 6 - HOUSEHOLD INCOME AGAINST INCOME BY GENDER (INTERACTABLE)
print("\n/////////////////")
print("Household Income Against Loan (Interactable) with GENDER")

filteredData = trainData[trainData['HouseholdIncome'] <= 120000].copy()
fig = px.scatter(
    filteredData,
    x="HouseholdIncome",
    y="LoanAmount",
    color="Gender",
    symbol="Loan_Status", 
    hover_data=["Loan_ID", "Loan_Status", "Gender", "Education", "Self_Employed","Married"], 
    title="Graph 5: Interactive Scatter Plot of Household Income vs Loan Amount with Approval Status and Gender Distribtution",
    labels={
        "HouseholdIncome": "Household Income",
        "LoanAmount": "Loan Amount",
        "IncomeGroup": "Income Group",
        "Loan_Status": "Loan Approval Status"
    },
    symbol_map={"Y": "circle", "N": "x"},  
)

fig.show()

trainData = trainData[trainData['HouseholdIncome'] <= 200000].copy()

class DataAnalysisGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("GUI")
        self.root.geometry("500x550")
        
        self.button_frame = tk.Frame(self.root)
        self.button_frame.pack(pady=20, fill="x")
        
        self.main_buttons = {
            "Data Overview": self.sub("Data Overview", self.summaryButton, self.meanValuesButton),
            "Graphs and Visuals": self.sub("Graphs and Visuals", self.ScatterButton, self.Bar),
            "Show Rows": self.sub("Show Rows", self.rowsDsiplay)
        }

        self.mainButtons()

    def mainButtons(self):
        for main, submenu in self.main_buttons.items():
            button = tk.Button(self.button_frame, text=main, command=lambda submenu=submenu: self.submenus(submenu))
            button.pack(padx=10, pady=10, side="top")

    def sub(self, category, *commands):
        frame = tk.Frame(self.root)
        subButtons = []
        
        for command in commands:
            button = tk.Button(frame, text=command.__name__.replace("show_", "").replace("_", " ").title(),command=command)
            subButtons.append(button)
        return frame, subButtons

    def submenus(self, submenu):
        frame, buttons = submenu
        
        if frame.winfo_ismapped():
            frame.pack_forget()
        else:
            frame.pack(padx=10, pady=10, fill="x")
            for button in buttons:
                button.pack(padx=10, pady=5, side="top")

    def summaryButton(self):
        meanIncome = trainData['HouseholdIncome'].mean()
        meanLoan = trainData['LoanAmount'].mean()
        message = f"Average Income: {meanIncome}\nAverage Loan Amount: {meanLoan}"
        messagebox.showinfo("Summary Statistics", message)

    def meanValuesButton(self):
        commonGender = trainData['Gender'].mode()[0]
        commonApproval = trainData['Loan_Status'].mode()[0]
        commomArea = trainData['Property_Area'].mode()[0]
        commonEducation = trainData['Education'].mode()[0]
        commonEmployed = trainData['Self_Employed'].mode()[0]
        commonCredit = trainData['Credit_History'].mode()[0]
        message = f"Most Common Gender: {commonGender}\nMost Common Loan Status: {commonApproval}\nMost Common Property Area: {commomArea} \nMost Common Educational Status: {commonEducation}\nMost Common Employment Status: {commonEmployed}\nMost Common Credit History Status (1=Yes, 0=No): {commonCredit}"
        messagebox.showinfo("Most Common Values", message)

    def ScatterButton(self):
        fig = px.scatter(
            filteredData,
            x="HouseholdIncome",
            y="LoanAmount",
            color="IncomeGroup",
            symbol="Loan_Status", 
            hover_data=["Loan_ID", "Loan_Status", "Gender", "Education", "Self_Employed","Married"], 
            title="Graph 5: Interactive Scatter Plot of Household Income vs Loan Amount with Approval Status and Income Bracket",
            labels={
                "HouseholdIncome": "Household Income",
                "LoanAmount": "Loan Amount",
                "IncomeGroup": "Income Group",
                "Loan_Status": "Loan Approval Status"
            },
            symbol_map={"Y": "circle", "N": "x"},  
        )

        fig.show()

    def Bar(self):
        plt.figure(figsize=(8, 6))
        sns.countplot(data=trainData, x="Loan_Status", hue="Gender")
        plt.title("Loan Status by Gender")
        plt.xlabel("Loan Status")
        plt.ylabel("Count")
        plt.show()


    def rowsDsiplay(self):
        userRowCount = simpledialog.askinteger("Show Rows", "How many rows would you like to display?", minvalue=1, maxvalue=trainData.shape[0])
        if userRowCount:
            displayRows = trainData.head(userRowCount)
            messagebox.showinfo("Selected Rows", displayRows.to_string())

root = tk.Tk()
app = DataAnalysisGUI(root)
root.mainloop()




 





